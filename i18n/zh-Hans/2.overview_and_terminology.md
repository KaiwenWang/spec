# 概述和术语

这部分提供了规范的概述和其中用到的技术术语的解释。它从明确运行云原生应用涉及到的组织内的不同角色开始，然后，展开解读贯穿规范全篇的特定术语。

## 角色和职责

作为规范的基础，需要定义如下角色。这些角色定义抽取于各种用户故事、调研和用户输入。尽管这些角色并不代表全部（有关角色），但是角色区分定义，是本规范的基本目标。

- __开发者__ 以代码形式交付业务价值。同时他们应该理解所交付代码的运维特性，他们不关心运维需求如何被满足。比如，开发者可能清楚自己的代码往文件系统上某个特定路径写数据，但是不必关心何种 volume 或磁盘挂载到这个路径上，或者依赖是怎么被满足的。

- __应用运维__ 通过配置、安装、管理组件和应用（比如更新、扩容、自动恢复等等）来传递业务价值。与开发者不同，应用运维关心的是组件和应用的运维需求如何被满足。比如，如果一个开发者声明组件写数据到文件系统的某个路径，应用运维人员需要将合适的volume挂载到这个path,来满足需求

- __基础设施运维__ 通过管理底层基础设施部分来体现价值。 其中，基础设施的范围可能包括从管理内网中的物理设备到直接管理公有云上的云服务等诸多维度。基础设施运维人员很少关注某个特定应用的配置需求，而更倾向于关注全局性的企业级基础设施该如何管理。比如，基础设施运维人员会管理用来提供持久化存储的底层系统。

在很多组织和机构，有些个人可能同时担任上述多种角色。同时，就像上面提到的案例，这些角色也经常需要彼此协作以便共同管理企业级应用程序。

## 模型概述

规范提倡如下定义云原生应用的模型：
> 云原生应用是一组相互关联但又彼此解耦的 _组件_（服务、任务、运行器），当通过配置组合起来并在适当的运行时实例化以后，共同完成一个统一的功能性目标。

模型定义如下：

 - _Components_ 代表一个可运行单元，同时附带语法描述
 - _Workload types_ 明确区分了组件可被执行的不同负载类型
 - _Traits_ 是用特定运维规范来增强Conponent后的的包装层，代表运维人员关注点，而非开发者关注点。
 - _Application scopes_ 通过共同属性或依赖来分组以代表应用边界
 - 一个 _application configuration_ 描述了一个包含Component、Trait、Application scopes的集合该如何组织，以及如何绑定配置参数和元数据。

所以，一个 _应用_ 包含了多个组件，每个组件附带一组运维特征，同时每个组件也都被囊括到了一个或多个应用边界中。

## 技术术语Terminology

下面的术语通用于本规范。

### Component Schematics
 
__组件 示意图__ 允许 __开发者__ 声明其所交付的代码的 _基础设施中立_ 的运维特性。除了不给开发者增加基础设施方面的关注负担之外，还解放了运维和运行时，让他们能够以其认为合理的方式来满足组件基础设施的需求。

组件示意图由下面这些信息组成：

- Workload Type: A declaration about what kind of runtime this component relies upon. (The platform will select a runtime that is capable of running this workload type.)
- Metadata: Information _about_ the component, primarily directed toward the user
- Resource requirements: The additional minimum needs that must be satisfied in order for the component to be executed. For example, minimum memory, CPU, and filesystem mounts
- Parameters: The parameters that can be adjusted for specific runtime configuration
- Workload definition: A list of the runnable pieces (OCI images, functions, etc.) used by this component. 

### Workloads and Workload Types

实现OAM的平台提供一个或一些能够运行component组件的运行时。每种能够被OAM 运行时运行的对象，又叫做 _workload type_ 描述了如下内容：

- Metadata: 有关 workload type 的基础信息
- Workload Settings: 运维人员可以提供给每个组件的workload的配置
  
### Traits
Trait 定义了一块与组件运维相关的附加功能。Trait 可能被限制用于某种特定的工作负载。并且不同的OAM实现可能提供或支持不同的Trait。Traits 代表运维关注而非开发者关注的系统feature。比如，一个开发者可能知道是否他们的组件能够被扩容（并且可以选择一个描述扩容的工作负载类型）。但是运维人员可能决定去应用人工扩容或者自动扩容Trait给这个组件。Trait描述如下：

- Metadata: Information about the trait
- Applies-to list: Enumeration of which workload types this trait applies to
- Properties: Configuration that may be specified in an application configuration

### Application scopes

应用范围 提供了不同的方式来将组件分组成应用。组件通过在组件上将范围名称作为标签来添加到范围。每个范围有相关的行为或功能，比如，网络应用范围内所有组件将可能会具备网络观测能力。

应用范围描述如下:

- Metadata: Information about the scope
- Type: The type of scope. Different types of scopes provide different capabilities.
- Parameters: Configuration that may be specified in an application configuration

### Application Configuration

应用配置一种声明一个应用(已经被描述为应用示意图和组件示意图)能够如何被实例化和配置的资源，包括哪个参数被覆盖和新增Trait。

应用配置包括如下部分：

- Metadata: Information about the installed application configuration
- Parameter Overrides: Values to supply to named parameters in the application or components
- Trait configuration: A list of traits to enable, together with parameter overrides for each trait
- Workload type settings: Overrides to workload type settings

## 将OAM对象表述为示意图

OAM规范将OAM对象 (components, trait definitions, application configurations等等) 表示为 _示意图_. 示意图是结构化的文档，提供了对对象或对象期望状态的声明。规范通篇，示意图用YAML来表示。当然，本规范中的任何内容都不能排除将示意图表示为JSON文档或其他类似结构的文本或二进制表示的可能性。

### The Structure of a Schematic

所有的示意图遵从统一模式. 顶级属性表示示意图的类型，包括 group, version和 kind (见上图). `metadata` 部分提供了特定示意图的信息。 规范中定义的所有示意图具有相同的 `metadata` 属性, 具体见如下描述。最后， `spec` 部分提供了示意图的规范。例如，`spec`部分的Trait 描述了trait本身，同时应用配置的`spec`部分描述了共同组成应用deployment的组件和Trait

下面关于 [Component](3.component_model.md) 的例子包含了上述三个部分：

```yaml
apiVersion: core.oam.dev/v1alpha1   ## Group and version
kind: ComponentSchematic            ## Kind
metadata:                           ## Metadata
  name: nginx-replicated
spec:                               ## Specification
  workloadType: core.oam.dev/v1alpha1.Server
  os: linux
  containers:
    - name: server
      image: nginx:latest
```

> OAM使用的表示格式来自Kubernetes。但OAM设计为不需要Kubernetes。

### Metadata

元数据部分在所有定义的示意图中都是通用的。它由几个顶级的Key组成。
元数据提供了关于对象的相关信息。


| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y | | | A name for the schematic. `name` is subject to the restrictions listed beneath this table. |
| `labels` | `map[string]string` | N | | A set of string key/value pairs used as arbitrary labels on this component. See the "Label format" section immediately below. | 
| `annotations` | `map[string]string`| N || A set of string key/value pairs used as arbitrary descriptive text associated with this object. See the "Annotations format" section immediately below. |

#### The `name` Field
group kind和name组成的字符串必须是唯一的。两个不同的kind（比如Component和Trait）可能有相同的name, 也不会冲突。Version 不是显著的影响因素。

*Okay:* Each kind allows the name `foo`.
```yaml
apiVersion: core.oam.dev/v1alpha1
kind: Component
metadata:
    name: foo
---
apiVersion: core.oam.dev/v1alpha1
kind: Trait
metadata:
    name: foo
```

*NOT Okay:* Version is not a namespace qualifier.

```yaml
apiVersion: core.oam.dev/v1alpha1
kind: Component
metadata:
    name: foo
---
apiVersion: core.oam.dev/v1
kind: Component
metadata:
    name: foo
```

 `name` 字段必须按照如下要求格式化：

> name字段 必须不超过63个字符，以字母数字字符（[a-z0-9A-Z]）开头和结尾，中间有破折号（-）、下划线（u）、点（.）和字母数字。

除非另有说明，否则名称在组/版本/种类中必须是唯一的。

#### Label Format

Labels follow the [Kubernetes specification](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) for labeling:
> 有效的标签有两部分：可选的前缀和名称，用斜线（/）分隔。名称是必需的，必须不超过63个字符，以字母数字字符（[a-z0-9A-Z]）开头和结尾，中间有破折号（-）、下划线（u）、点（.）和字母数字。前缀是可选的。如果指定，前缀必须是DNS子域：由点（.）分隔的一系列DNS标签，总共不超过253个字符，后跟斜杠（/）。

#### Annotations Format

注解提供了一种在对象的元数据中附加任意文本的机制. 注解对象遵循 [Kubernetes specification](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set):

> 注解是key/value对。合格的注解key必须包含两部分：可选的前缀和名称，用斜线（/）分隔。名称是必需的，必须不超过63个字符，以字母数字字符（[a-z0-9A-Z]）开头和结尾，中间有破折号（-）、下划线（u）、点（.）和字母数字。前缀是可选的。如果指定，前缀必须是DNS子域：由点（.）分隔的一系列DNS标签，总共不超过253个字符，后跟斜杠（/）。

The following annotation labels are _predefined_ and are _strongly recommended_.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `description` | `string` | N | | A short description of the component. |
| `version` | `string` | N | | A string defining the [semantic version](https://semver.org/) of the component. |

If `version` is not supplied, the default version is assumed to be `0.1.0`, per the SemVer specification.

Example:

```yaml
metadata:
  name: alpine-task
  labels:
    app: my-app-v1  # Non-normative example
  annotations:
    version: "1.0.1"
    description: A task that is backed by an Alpine Linux filesystem
```

元数据部分在所有示意图中都使用。它还与Kubernetes元数据部分兼容。但是，请注意，Kubernetes元数据是OAM元数据的超集，包含OAM无法识别的属性。


## Group, Version, and Kind

本文档中描述的许多API对象都使用了一个名为“Group，Version，Kind”的命名方案。这个由Kubernetes推广的方案提供了一种一致的API对象的名称空间和版本控制方法，并在这里用于OAM API版本控制。

> Applications, components, containers和其他实体可能有其自身的版本体系。 此方案仅适用于API对象，如组件原理图、应用程序原理图、工作负载类型和特征。

这部分内容讲述这个体系。

### Group
Group是聚合几个相关Kind的命名空间，使用DNS命名约定。例如：

- components.oam.dev
- functions.azure.com
- my.dev

`oam.dev`域名下的所有Group 被认为是为规范保留的。这里指定的所有对象都属于该域中的Group。

Group 必须全局唯一。

### Version

版本字符串是API版本。遵循通用的范例，api只按主要数字进行版本控制。API版本中省略了次要和修补程序编号。底层引擎的实际次要版本和修补程序版本可能会迭代，但它们必须迭代此版本以进行任何中断更改。换言之，主编号是兼容性的保证，而次编号和修补程序编号不应更改该保证。因此，API的使用者不能指定比主版本更细的粒度。

API版本号总是以`v`开头，然后附缀一个或几个数字

Examples:

- `v1`
- `v2`
- `v973`

主版本号有两个附带修饰符：

- `alphaN` (where `N` is one or more digits) indicates that this feature is experimental, and may be removed, but that its current compatibility marker is `1`
- `betaN` (where `N` is one or more digits) indicates that this feature is not yet stable. The `N` is a compatibility marker.

标记为 `alpha` 或 `beta` 的API 版本被认为是不稳定且可能改变
两种版本修饰符只能同时出现一个。

- `v1alpha1`
- `v973beta231`

兼容性建立在精确完全匹配的基础上，v1 不兼容v2,v1aplha1,v1beta2。

版本没有唯一性要求。

### Kind

The _kind_ is the name of a type. For example, a component schematic's kind is `ComponentSchematic`, while a trait's kind is `Trait`. Kinds are always composed of words where the initial letter is capitalized, and the first letter of every word is capitalized. Kinds _should_ capitalize every letter of an acronym (`HTTP`, not `Http`).

Kinds MUST be unique within a group.

### Representations of Group/Version/Kind

The fully qualified representation of Group/Version/Kind is `GROUP/VERSION.KIND`. Here are some examples:

- `local.dev/v7alpha2.Proxy`
- `cache.example.com/v1.Redis`
- `azure.com/v2.Functions`

In schematics, the group and version are presented on one field, and the kind is presented on another:

```yaml
apiVersion: local.dev/v7alpha2
kind: Proxy
```

In rare cases, it is necessary to link a group and a kind, but without specifying a version. This is done, for example, when declaring default workload types. As a general rule, this behavior should be avoided whenever necessary, but when it is necessary, this specification follows the Kubernetes pattern of construct a DNS name out of the plural kind name and the group:

```
Proxies.local.dev # allowed but discouraged
```

This form is not accepted as an alternative for the fully qualified version. It is only accepted in cases where it is explicitly stated by the specification that this form is accepted.


| Previous Part        | Next Part          |
| ------------- |-------------|
|[1. 目标与愿景](1.purpose_and_goals.md)| [3. 组件模型](3.component_model.md)|